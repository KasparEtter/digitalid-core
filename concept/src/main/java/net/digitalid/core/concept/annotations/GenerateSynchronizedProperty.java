package net.digitalid.core.concept.annotations;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.Map;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;

import net.digitalid.utility.annotations.method.Impure;
import net.digitalid.utility.annotations.method.Pure;
import net.digitalid.utility.annotations.ownership.Captured;
import net.digitalid.utility.annotations.state.Modifiable;
import net.digitalid.utility.circumfixes.Brackets;
import net.digitalid.utility.circumfixes.Quotes;
import net.digitalid.utility.collections.list.FreezableArrayList;
import net.digitalid.utility.contracts.Require;
import net.digitalid.utility.contracts.exceptions.PreconditionViolationException;
import net.digitalid.utility.conversion.converter.types.CustomType;
import net.digitalid.utility.functional.failable.FailableConsumer;
import net.digitalid.utility.generator.annotations.meta.Interceptor;
import net.digitalid.utility.generator.information.method.MethodInformation;
import net.digitalid.utility.generator.information.type.TypeInformation;
import net.digitalid.utility.generator.interceptor.MethodInterceptor;
import net.digitalid.utility.processing.utility.ProcessingUtility;
import net.digitalid.utility.processor.generator.JavaFileGenerator;
import net.digitalid.utility.validation.annotations.generation.Default;
import net.digitalid.utility.validation.annotations.type.Stateless;
import net.digitalid.utility.validation.contract.Contract;
import net.digitalid.utility.validation.processing.AnnotationHandlerUtility;
import net.digitalid.utility.validation.validator.ValueAnnotationValidator;

/**
 * Description.
 */
@Documented
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Interceptor(GenerateSynchronizedProperty.Interceptor.class)
public @interface GenerateSynchronizedProperty {
    
    // TODO: Implement the interceptor that generates the property with the info.
    /*
    @Generated("TODO in Subclass") // TODO: This should be generated by the '@GenerateProperty' annotation in the subclass.
    private static final @Nonnull FailableConsumer<String, PreconditionViolationException> PASSWORD_VALIDATOR = new FailableConsumer<String, PreconditionViolationException>() {
            
            @Impure
            @Override
            public void consume(@Captured String password) throws PreconditionViolationException {
                Require.that(password.length() <= 50).orThrow("The password may be at most 50 characters long.");
            }
            
    }
    
    @Generated("TODO in Subclass") // TODO: This should be generated by the '@GenerateProperty' annotation in the subclass.
    private static final @Nonnull NonNullableConceptPropertyInfo<@MaxSize(50) String, Settings, NonHostEntity> PASSWORD = NonNullableConceptPropertyInfoBuilder.withConceptInfo(INFO).withPropertyName("password").withValueConverter(StringConverter.INSTANCE).withRequiredAuthorization(PASSWORD_AUTHORIZATION).withValueValidator(PASSWORD_VALIDATOR).withDefaultValue("").build();
    
    private final @Nonnull NonNullableConceptProperty password = NonNullableConceptProperty.with(PASSWORD, this);
     */
    
    /**
     * This class generates content for the annotated method.
     */
    @Stateless
    public static class Interceptor extends MethodInterceptor {
        
        @Pure
        @Override
        protected @Nonnull String getPrefix() {
            return "";
        }
        
        @Pure
        @Override
        public void generateFieldsRequiredByMethod(@Nonnull JavaFileGenerator javaFileGenerator, @Nonnull MethodInformation method, @Nonnull TypeInformation typeInformation) {
            final @Nonnull FreezableArrayList<@Nonnull Contract> contracts = FreezableArrayList.withNoElements();
    
            final @Nullable TypeMirror componentType = ProcessingUtility.getComponentType(method.getReturnType());
            final @Nullable TypeElement typeElement = ProcessingUtility.getTypeElement(componentType);
            final @Modifiable @Nonnull Map<@Nonnull AnnotationMirror, @Nonnull ValueAnnotationValidator> valueValidators = AnnotationHandlerUtility.getValueValidators(typeElement);
            for (Map.@Nonnull Entry<@Nonnull AnnotationMirror, @Nonnull ValueAnnotationValidator> valueValidatorEntry : valueValidators.entrySet()) {
                final @Nullable Contract contract = valueValidatorEntry.getValue().generateContract(typeElement, valueValidatorEntry.getKey(), javaFileGenerator);
                contracts.add(contract);
            }
            
            final @Nonnull String validationContent = contracts.map(contract -> javaFileGenerator.importIfPossible(Require.class) + ".that" + Brackets.inRound(contract.getCondition()) + ".orThrow" + Brackets.inRound(contract.getMessage() + ", " + contract.getArguments().join()) + ";").join("\n");
    
            javaFileGenerator.addField("private static final @" + javaFileGenerator.importIfPossible(Nonnull.class) + " " + javaFileGenerator.importIfPossible(FailableConsumer.class) + Brackets.inPointy(javaFileGenerator.importIfPossible(String.class) + ", " + javaFileGenerator.importIfPossible(PreconditionViolationException.class)) + method.getName().toUpperCase() + "_VALIDATOR = new " + javaFileGenerator.importIfPossible(FailableConsumer.class) + Brackets.inPointy(javaFileGenerator.importIfPossible(String.class) + ", " + javaFileGenerator.importIfPossible(PreconditionViolationException.class)) + "() {\n\n " +
            
                    "@" + javaFileGenerator.importIfPossible(Impure.class) + "\n" +
                    "@" + javaFileGenerator.importIfPossible(Override.class) + "\n" +
                    "public void consume(@" + javaFileGenerator.importIfPossible(Captured.class) + javaFileGenerator.importIfPossible(String.class) + " password) throws " + javaFileGenerator.importIfPossible(PreconditionViolationException.class) + " {\n" + validationContent + "\n}" +
            "}\n}");
            
            final @Nonnull String upperCasePropertyName = method.getName().toUpperCase();
            
            javaFileGenerator.addField("private static final @" + javaFileGenerator.importIfPossible(Nonnull.class) + " " + javaFileGenerator.importIfPossible(method.getReturnType() + "Info") + Brackets.inPointy(componentType) + " " + upperCasePropertyName + " = " + javaFileGenerator.importIfPossible(method.getReturnType() + "InfoBuilder") + ".withConceptInfo(\"INFO\").withPropertyName" + Brackets.inRound(Quotes.inDouble(method.getName()) + ".withValueConverter" + Brackets.inRound("DynamicConverterBuilder.withType" + Brackets.inRound(CustomType.getTypeName(componentType, javaFileGenerator)) + ".withName" + Brackets.inRound(method.getName()) /* TODO: .withCustomAnnotations */) + ".withRequiredAuthorization" + Brackets.inRound(upperCasePropertyName + "_AUTHORIZATION") + ".withValueValidator" + Brackets.inRound(upperCasePropertyName + "_VALIDATOR") + ".withDefaultValue" + Brackets.inRound((method.hasAnnotation(Default.class) ? Quotes.inDouble(method.getAnnotation(Default.class).value()) : "null")) + ".build()"));
            
            javaFileGenerator.addField("private final @" + javaFileGenerator.importIfPossible(Nonnull.class) + " " + javaFileGenerator.importIfPossible(method.getReturnType()) + " " + method.getName() + " = " + javaFileGenerator.importIfPossible(method.getReturnType()) + ".with" + Brackets.inRound(upperCasePropertyName + ", this"));
        }
        
        @Pure
        @Override
        protected void implementInterceptorMethod(@Nonnull JavaFileGenerator javaFileGenerator, @Nonnull MethodInformation method, @Nonnull String statement, @Nullable String resultVariable, @Nullable String defaultValue) {
        }
    
    }
}
